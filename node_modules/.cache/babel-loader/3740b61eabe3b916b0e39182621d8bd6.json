{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\dev1\\\\Ludo-React\\\\src\\\\components\\\\coin.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport _ from \"lodash\";\nimport { currentPlayerState, allCoinState, allBlockState, currentDiceState, currentPlayersListState } from \"../recoil/atoms\";\nimport { startMoves, moves, starIndexes, colorMap } from \"../config/constants\";\nimport coinPalegreen from \"../assets/coinPalegreen.svg\";\nimport coinYellow from \"../assets/coinYellow.svg\";\nimport coinTomato from \"../assets/coinTomato.svg\";\nimport coinRoyalblue from \"../assets/coinRoyalblue.svg\";\nimport coinMoveSound from \"../assets/coinMove.mp3\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst images = {\n  palegreen: coinPalegreen,\n  yellow: coinYellow,\n  tomato: coinTomato,\n  royalblue: coinRoyalblue\n};\n/**\r\n * Component for COIN that moves over entire board.\r\n * @param {Object} props\r\n * @returns JSX\r\n */\n\nfunction Coin({\n  parent,\n  index,\n  className\n}) {\n  _s();\n\n  const [currentPlayer, setCurrentPlayer] = useRecoilState(currentPlayerState);\n  const [coinState, setCoinState] = useRecoilState(allCoinState);\n  const [blockState, setBlockState] = useRecoilState(allBlockState);\n  const [diceState, setDiceState] = useRecoilState(currentDiceState);\n  const playersList = useRecoilValue(currentPlayersListState);\n  const {\n    position: currentPosition,\n    isTurnAvailable\n  } = coinState[parent][index]; // checks if the current position of coin is not home or won\n\n  const isPositionNotHomeOrWon = [\"home\", \"won\"].every(x => !currentPosition.includes(x));\n  const parentMoves = moves[parent]; // Calculate next possible move for current coin\n\n  const nextMove = isPositionNotHomeOrWon ? diceState.num && parentMoves.indexOf(currentPosition) + diceState.num < parentMoves.length ? parentMoves[parentMoves.indexOf(currentPosition) + diceState.num] : null : currentPosition === \"home\" ? startMoves[parent] : \"\"; // Check with nextMove & diceNum; if the coin can move or not\n\n  const moveableClass = currentPlayer === parent && nextMove ? // (!currentPosition && nextMove) ||\n  // currentPosition === nextMove\n  // ? \"\"\n  // :\n  isTurnAvailable ? isPositionNotHomeOrWon || diceState.num === 6 ? \" current-player-animation\" : \"\" : isPositionNotHomeOrWon && diceState.num ? \" current-player-animation\" : \"\" : \"\";\n  /**\r\n   * This useEffect tracks the dice change and accordingly sets `isTurnAvailable`\r\n   * and also changes the player if next moe is not possible\r\n   */\n\n  useEffect(() => {\n    const currentPlayerCoins = coinState[parent];\n\n    if (diceState.num && currentPlayer === parent) {\n      const updatedState = _.cloneDeep(currentPlayerCoins);\n\n      let moveAvailCount = 0;\n      Object.keys(updatedState).forEach(key => {\n        const position = updatedState[key].position;\n\n        if (position === \"home\" && diceState.num === 6 || [\"home\", \"won\"].every(x => !position.includes(x)) && parentMoves.indexOf(position) + diceState.num < parentMoves.length) {\n          console.log({\n            position\n          });\n          updatedState[key].isTurnAvailable = true;\n          moveAvailCount++;\n        } else {\n          updatedState[key].isTurnAvailable = false;\n        }\n      });\n      console.log({\n        moveAvailCount\n      });\n      setCoinState({ ...coinState,\n        [parent]: updatedState\n      });\n      !moveAvailCount && changePlayer();\n    }\n  }, [diceState.num]);\n  /**\r\n   * This function updates the coin and block states accordingly, also checks if either of the coin is being killed by other.\r\n   * @param {String} parentKey              The nextMove the current coin should move to.\r\n   * @param {Object} updatedFullCoinState   Updated entire coin state object.\r\n   * @param {Object} updatedFullBlockState  Updated entire block state object.\r\n   * @param {Function} cb                   Should be called with a parameter i.e; number coins that have killed by some other coin.\r\n   * @returns void\r\n   */\n\n  const updateCoinBlockStates = (parentKey, updatedFullCoinState, updatedFullBlockState, cb) => {\n    setCoinState(updatedFullCoinState);\n    setBlockState(updatedFullBlockState);\n    updatedFullCoinState = _.cloneDeep(updatedFullCoinState);\n    let updatedBlockState = [];\n    let coinsToBeReset = [];\n    let isStateUpdated = false;\n    const currentState = updatedFullBlockState[parentKey];\n\n    if (!starIndexes.includes(parentKey) && currentState.length > 1) {\n      currentState.forEach(elem => {\n        const allMatched = updatedBlockState.every(item => item.startsWith(elem[0]));\n        if (allMatched) updatedBlockState.push(elem);else {\n          coinsToBeReset.push(...updatedBlockState);\n          updatedBlockState = [elem];\n        }\n      });\n      if (coinsToBeReset.length) coinsToBeReset.forEach(key => {\n        updatedFullCoinState[colorMap[key[0]]][key].position = \"home\";\n      });\n      isStateUpdated = true;\n    }\n\n    if (isStateUpdated) {\n      setCoinState(updatedFullCoinState);\n      setBlockState({ ...updatedFullBlockState,\n        [parentKey]: [...new Set(updatedBlockState)]\n      });\n    }\n\n    return cb(!!coinsToBeReset.length);\n  }; // Changes the player to next possible\n\n\n  const changePlayer = () => {\n    const currentPlayerIndex = playersList.indexOf(currentPlayer);\n    const nextPlayer = currentPlayerIndex === -1 || !playersList[currentPlayerIndex + 1] ? playersList[0] : playersList[currentPlayerIndex + 1];\n    setTimeout(() => {\n      setDiceState({\n        num: 0,\n        isLocked: false,\n        lastRolledBy: currentPlayer\n      });\n      setCurrentPlayer(nextPlayer);\n    }, 500);\n  };\n  /**\r\n   * This function is called as a event handler onClick on coin.\r\n   * Updates the coin positions and changes the player if required.\r\n   * @returns void\r\n   */\n\n\n  const playTurn = () => {\n    // prevent other player's coin moving on click when turn in of other\n    if (parent !== currentPlayer || !diceState.num || !moveableClass) return; // const { position: currentPosition } = coinState[parent][index];\n    // if (!nextMove) return changePlayer();\n\n    new Audio(coinMoveSound).play();\n\n    const updatedCoinState = _.cloneDeep({ ...coinState[parent],\n      [index]: {\n        position: nextMove,\n        isTurnAvailable: false\n      }\n    });\n\n    const updatedBlockState = _.cloneDeep(blockState);\n\n    isPositionNotHomeOrWon && updatedBlockState[currentPosition].splice(updatedBlockState[currentPosition].indexOf(index), 1);\n    updatedBlockState[nextMove] = [...new Set([...(blockState[nextMove] || []), index])];\n    updateCoinBlockStates(nextMove, { ...coinState,\n      [parent]: updatedCoinState\n    }, updatedBlockState, isKilledSomeone => {\n      !isKilledSomeone && !nextMove.includes(\"won\") && diceState.num !== 6 && changePlayer();\n      setDiceState({\n        num: 0,\n        isLocked: false,\n        lastRolledBy: currentPlayer\n      });\n    });\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"coin\" + moveableClass,\n    onClick: playTurn // parent={parent}\n    // index={index}\n    // isMoveable={moveableClass}\n    ,\n    children: /*#__PURE__*/_jsxDEV(\"img\", {\n      src: images[parent],\n      className: className\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 218,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Coin, \"yOQOaxovWXcyDAXBCX1YBjmDVLs=\", false, function () {\n  return [useRecoilState, useRecoilState, useRecoilState, useRecoilState, useRecoilValue];\n});\n\n_c = Coin;\nexport default Coin;\n\nvar _c;\n\n$RefreshReg$(_c, \"Coin\");","map":{"version":3,"sources":["C:/Users/dev1/Ludo-React/src/components/coin.js"],"names":["useState","useEffect","useRecoilState","useRecoilValue","_","currentPlayerState","allCoinState","allBlockState","currentDiceState","currentPlayersListState","startMoves","moves","starIndexes","colorMap","coinMoveSound","images","palegreen","coinPalegreen","yellow","coinYellow","tomato","coinTomato","royalblue","coinRoyalblue","Coin","parent","index","className","currentPlayer","setCurrentPlayer","coinState","setCoinState","blockState","setBlockState","diceState","setDiceState","playersList","position","currentPosition","isTurnAvailable","isPositionNotHomeOrWon","every","x","includes","parentMoves","nextMove","num","indexOf","length","moveableClass","currentPlayerCoins","updatedState","cloneDeep","moveAvailCount","Object","keys","forEach","key","console","log","changePlayer","updateCoinBlockStates","parentKey","updatedFullCoinState","updatedFullBlockState","cb","updatedBlockState","coinsToBeReset","isStateUpdated","currentState","elem","allMatched","item","startsWith","push","Set","currentPlayerIndex","nextPlayer","setTimeout","isLocked","lastRolledBy","playTurn","Audio","play","updatedCoinState","splice","isKilledSomeone"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\r\nimport { useRecoilState, useRecoilValue } from \"recoil\";\r\nimport _ from \"lodash\";\r\n\r\nimport {\r\n  currentPlayerState,\r\n  allCoinState,\r\n  allBlockState,\r\n  currentDiceState,\r\n  currentPlayersListState,\r\n} from \"../recoil/atoms\";\r\nimport { startMoves, moves, starIndexes, colorMap } from \"../config/constants\";\r\nimport coinPalegreen from \"../assets/coinPalegreen.svg\";\r\nimport coinYellow from \"../assets/coinYellow.svg\";\r\nimport coinTomato from \"../assets/coinTomato.svg\";\r\nimport coinRoyalblue from \"../assets/coinRoyalblue.svg\";\r\nimport coinMoveSound from \"../assets/coinMove.mp3\";\r\n\r\nconst images = {\r\n  palegreen: coinPalegreen,\r\n  yellow: coinYellow,\r\n  tomato: coinTomato,\r\n  royalblue: coinRoyalblue,\r\n};\r\n\r\n/**\r\n * Component for COIN that moves over entire board.\r\n * @param {Object} props\r\n * @returns JSX\r\n */\r\nfunction Coin({ parent, index, className }) {\r\n  const [currentPlayer, setCurrentPlayer] = useRecoilState(currentPlayerState);\r\n  const [coinState, setCoinState] = useRecoilState(allCoinState);\r\n  const [blockState, setBlockState] = useRecoilState(allBlockState);\r\n  const [diceState, setDiceState] = useRecoilState(currentDiceState);\r\n  const playersList = useRecoilValue(currentPlayersListState);\r\n\r\n  const { position: currentPosition, isTurnAvailable } =\r\n    coinState[parent][index];\r\n\r\n  // checks if the current position of coin is not home or won\r\n  const isPositionNotHomeOrWon = [\"home\", \"won\"].every(\r\n    (x) => !currentPosition.includes(x)\r\n  );\r\n\r\n  const parentMoves = moves[parent];\r\n  // Calculate next possible move for current coin\r\n  const nextMove = isPositionNotHomeOrWon\r\n    ? diceState.num &&\r\n      parentMoves.indexOf(currentPosition) + diceState.num < parentMoves.length\r\n      ? parentMoves[parentMoves.indexOf(currentPosition) + diceState.num]\r\n      : null\r\n    : currentPosition === \"home\"\r\n    ? startMoves[parent]\r\n    : \"\";\r\n\r\n  // Check with nextMove & diceNum; if the coin can move or not\r\n  const moveableClass =\r\n    currentPlayer === parent && nextMove\r\n      ? // (!currentPosition && nextMove) ||\r\n        // currentPosition === nextMove\r\n        // ? \"\"\r\n        // :\r\n        isTurnAvailable\r\n        ? isPositionNotHomeOrWon || diceState.num === 6\r\n          ? \" current-player-animation\"\r\n          : \"\"\r\n        : isPositionNotHomeOrWon && diceState.num\r\n        ? \" current-player-animation\"\r\n        : \"\"\r\n      : \"\";\r\n\r\n  /**\r\n   * This useEffect tracks the dice change and accordingly sets `isTurnAvailable`\r\n   * and also changes the player if next moe is not possible\r\n   */\r\n  useEffect(() => {\r\n    const currentPlayerCoins = coinState[parent];\r\n\r\n    if (diceState.num && currentPlayer === parent) {\r\n      const updatedState = _.cloneDeep(currentPlayerCoins);\r\n      let moveAvailCount = 0;\r\n\r\n      Object.keys(updatedState).forEach((key) => {\r\n        const position = updatedState[key].position;\r\n        if (\r\n          (position === \"home\" && diceState.num === 6) ||\r\n          ([\"home\", \"won\"].every((x) => !position.includes(x)) &&\r\n            parentMoves.indexOf(position) + diceState.num < parentMoves.length)\r\n        ) {\r\n          console.log({ position });\r\n          updatedState[key].isTurnAvailable = true;\r\n          moveAvailCount++;\r\n        } else {\r\n          updatedState[key].isTurnAvailable = false;\r\n        }\r\n      });\r\n\r\n      console.log({ moveAvailCount });\r\n\r\n      setCoinState({ ...coinState, [parent]: updatedState });\r\n      !moveAvailCount && changePlayer();\r\n    }\r\n  }, [diceState.num]);\r\n\r\n  /**\r\n   * This function updates the coin and block states accordingly, also checks if either of the coin is being killed by other.\r\n   * @param {String} parentKey              The nextMove the current coin should move to.\r\n   * @param {Object} updatedFullCoinState   Updated entire coin state object.\r\n   * @param {Object} updatedFullBlockState  Updated entire block state object.\r\n   * @param {Function} cb                   Should be called with a parameter i.e; number coins that have killed by some other coin.\r\n   * @returns void\r\n   */\r\n  const updateCoinBlockStates = (\r\n    parentKey,\r\n    updatedFullCoinState,\r\n    updatedFullBlockState,\r\n    cb\r\n  ) => {\r\n    setCoinState(updatedFullCoinState);\r\n    setBlockState(updatedFullBlockState);\r\n    updatedFullCoinState = _.cloneDeep(updatedFullCoinState);\r\n    let updatedBlockState = [];\r\n    let coinsToBeReset = [];\r\n    let isStateUpdated = false;\r\n\r\n    const currentState = updatedFullBlockState[parentKey];\r\n    if (!starIndexes.includes(parentKey) && currentState.length > 1) {\r\n      currentState.forEach((elem) => {\r\n        const allMatched = updatedBlockState.every((item) =>\r\n          item.startsWith(elem[0])\r\n        );\r\n        if (allMatched) updatedBlockState.push(elem);\r\n        else {\r\n          coinsToBeReset.push(...updatedBlockState);\r\n          updatedBlockState = [elem];\r\n        }\r\n      });\r\n\r\n      if (coinsToBeReset.length)\r\n        coinsToBeReset.forEach((key) => {\r\n          updatedFullCoinState[colorMap[key[0]]][key].position = \"home\";\r\n        });\r\n\r\n      isStateUpdated = true;\r\n    }\r\n\r\n    if (isStateUpdated) {\r\n      setCoinState(updatedFullCoinState);\r\n      setBlockState({\r\n        ...updatedFullBlockState,\r\n        [parentKey]: [...new Set(updatedBlockState)],\r\n      });\r\n    }\r\n    return cb(!!coinsToBeReset.length);\r\n  };\r\n\r\n  // Changes the player to next possible\r\n  const changePlayer = () => {\r\n    const currentPlayerIndex = playersList.indexOf(currentPlayer);\r\n    const nextPlayer =\r\n      currentPlayerIndex === -1 || !playersList[currentPlayerIndex + 1]\r\n        ? playersList[0]\r\n        : playersList[currentPlayerIndex + 1];\r\n\r\n    setTimeout(() => {\r\n      setDiceState({ num: 0, isLocked: false, lastRolledBy: currentPlayer });\r\n      setCurrentPlayer(nextPlayer);\r\n    }, 500);\r\n  };\r\n\r\n  /**\r\n   * This function is called as a event handler onClick on coin.\r\n   * Updates the coin positions and changes the player if required.\r\n   * @returns void\r\n   */\r\n  const playTurn = () => {\r\n    // prevent other player's coin moving on click when turn in of other\r\n    if (parent !== currentPlayer || !diceState.num || !moveableClass) return;\r\n\r\n    // const { position: currentPosition } = coinState[parent][index];\r\n\r\n    // if (!nextMove) return changePlayer();\r\n\r\n    new Audio(coinMoveSound).play();\r\n\r\n    const updatedCoinState = _.cloneDeep({\r\n      ...coinState[parent],\r\n      [index]: { position: nextMove, isTurnAvailable: false },\r\n    });\r\n\r\n    const updatedBlockState = _.cloneDeep(blockState);\r\n\r\n    isPositionNotHomeOrWon &&\r\n      updatedBlockState[currentPosition].splice(\r\n        updatedBlockState[currentPosition].indexOf(index),\r\n        1\r\n      );\r\n    updatedBlockState[nextMove] = [\r\n      ...new Set([...(blockState[nextMove] || []), index]),\r\n    ];\r\n\r\n    updateCoinBlockStates(\r\n      nextMove,\r\n      { ...coinState, [parent]: updatedCoinState },\r\n      updatedBlockState,\r\n      (isKilledSomeone) => {\r\n        !isKilledSomeone &&\r\n          !nextMove.includes(\"won\") &&\r\n          diceState.num !== 6 &&\r\n          changePlayer();\r\n        setDiceState({ num: 0, isLocked: false, lastRolledBy: currentPlayer });\r\n      }\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={\"coin\" + moveableClass}\r\n      onClick={playTurn}\r\n      // parent={parent}\r\n      // index={index}\r\n      // isMoveable={moveableClass}\r\n    >\r\n      <img src={images[parent]} className={className} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Coin;\r\n"]},"metadata":{},"sourceType":"module"}